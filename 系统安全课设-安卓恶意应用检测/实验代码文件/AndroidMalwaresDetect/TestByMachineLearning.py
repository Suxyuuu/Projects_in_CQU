#该模块将集成朴素贝叶斯，决策树，正交向量机，随机森林等算法来测试特征效果

import AndroidMalwaresDetect.GetTrainList as GetTrainList

import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import BernoulliNB
from sklearn.naive_bayes import MultinomialNB
from sklearn.naive_bayes import GaussianNB
from sklearn import tree
from sklearn import metrics
from sklearn import svm
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import cross_val_score


def dividedataset(good_feature_vector_list, bad_feature_vector_list):
    X=GetTrainList.get_x_train(good_feature_vector_list,bad_feature_vector_list)
    Y=GetTrainList.get_y_train(good_feature_vector_list,bad_feature_vector_list)
    X_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size=0.3,random_state=0)#随机选择训练集和测试集

    return X_train, X_test, Y_train, Y_test

#高斯贝叶斯
def naviebayes_G(good_feature_vector_list,bad_feature_vector_list):
    X=GetTrainList.get_x_train(good_feature_vector_list,bad_feature_vector_list)
    Y=GetTrainList.get_y_train(good_feature_vector_list,bad_feature_vector_list)
    X_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size=0.3,random_state=0)#随机选择训练集和测试集
    
    gnb = GaussianNB()
    gnb.fit(X_train, Y_train)
    Y_pred = gnb.predict(X_test)
    
    print("朴素贝叶斯测试结果：")

    print("分类正确率ACC：")
    print(metrics.accuracy_score(Y_test,Y_pred))
    #print("混淆矩阵：")
    m=metrics.confusion_matrix(Y_test,Y_pred)
    #print(m)
    print("真正率TPR：")#预测为真实际为真
    print(metrics.recall_score(Y_test,Y_pred))
    print("真负率TNR：")#预测为假实际为假
    print(m[1][1]/(m[0][1]+m[1][1]))
    print("十折交叉验证：")
    score = cross_val_score(gnb, X, Y, n_jobs=-1, cv=10)
    print(np.mean(score))
    print(" ")

#伯努利贝叶斯
def naviebayes_B(good_feature_vector_list,bad_feature_vector_list):
    X=GetTrainList.get_x_train(good_feature_vector_list,bad_feature_vector_list)
    Y=GetTrainList.get_y_train(good_feature_vector_list,bad_feature_vector_list)
    X_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size=0.3,random_state=0)#随机选择训练集和测试集
    
    bnb = BernoulliNB()
    bnb.fit(X_train, Y_train)
    Y_pred = bnb.predict(X_test)
    
    print("朴素贝叶斯测试结果：")

    print("分类正确率ACC：")
    print(metrics.accuracy_score(Y_test,Y_pred))
    #print("混淆矩阵：")
    m=metrics.confusion_matrix(Y_test,Y_pred)
    #print(m)
    print("真正率TPR：")#预测为真实际为真
    print(metrics.recall_score(Y_test,Y_pred))
    print("真负率TNR：")#预测为假实际为假
    print(m[1][1]/(m[0][1]+m[1][1]))
    print("十折交叉验证：")
    score = cross_val_score(bnb, X, Y, n_jobs=-1, cv=10)
    print(np.mean(score))
    print(" ")

#多项式贝叶斯
def naviebayes_M(good_feature_vector_list,bad_feature_vector_list):
    X=GetTrainList.get_x_train(good_feature_vector_list,bad_feature_vector_list)
    Y=GetTrainList.get_y_train(good_feature_vector_list,bad_feature_vector_list)
    X_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size=0.3,random_state=0)#随机选择训练集和测试集
    
    mnb = MultinomialNB()
    mnb.fit(X_train, Y_train)
    Y_pred = mnb.predict(X_test)
    
    print("朴素贝叶斯测试结果：")

    print("分类正确率ACC：")
    print(metrics.accuracy_score(Y_test,Y_pred))
    #print("混淆矩阵：")
    m=metrics.confusion_matrix(Y_test,Y_pred)
    #print(m)
    print("真正率TPR：")#预测为真实际为真
    print(metrics.recall_score(Y_test,Y_pred))
    print("真负率TNR：")#预测为假实际为假
    print(m[1][1]/(m[0][1]+m[1][1]))
    print("十折交叉验证：")
    score = cross_val_score(mnb, X, Y, n_jobs=-1, cv=10)
    print(np.mean(score))
    print(" ")

def decisiontree(good_feature_vector_list,bad_feature_vector_list):
    X=GetTrainList.get_x_train(good_feature_vector_list,bad_feature_vector_list)
    Y=GetTrainList.get_y_train(good_feature_vector_list,bad_feature_vector_list)
    X_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size=0.3,random_state=0)#随机选择训练集和测试集
    
    clf = tree.DecisionTreeClassifier()
    clf.fit(X_train,Y_train)
    Y_pred = clf.predict(X_test)

    print("决策树测试结果：")

    print("分类正确率ACC：")
    print(metrics.accuracy_score(Y_test,Y_pred))
    #print("混淆矩阵：")
    m=metrics.confusion_matrix(Y_test,Y_pred)
    #print(m)
    print("真正率TPR：")#预测为真实际为真
    print(metrics.recall_score(Y_test,Y_pred))
    print("真负率TNR：")#预测为假实际为假
    print(m[1][1]/(m[0][1]+m[1][1]))
    #print("十折交叉验证：")
    #score = cross_val_score(clf, X, Y, n_jobs=-1, cv=10)
    #print(np.mean(score))
    print(" ")

def SVM(good_feature_vector_list,bad_feature_vector_list):
    X=GetTrainList.get_x_train(good_feature_vector_list,bad_feature_vector_list)
    Y=GetTrainList.get_y_train(good_feature_vector_list,bad_feature_vector_list)
    X_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size=0.3,random_state=0)#随机选择训练集和测试集
    
    clf = svm.SVC(kernel='linear',C=1)
    clf.fit(X_train,Y_train)
    Y_pred = clf.predict(X_test)

    print("正交向量机测试结果：")

    print("分类正确率ACC：")
    print(metrics.accuracy_score(Y_test,Y_pred))
    #print("混淆矩阵：")
    m=metrics.confusion_matrix(Y_test,Y_pred)
    #print(m)
    print("真正率TPR：")#预测为真实际为真
    print(metrics.recall_score(Y_test,Y_pred))
    print("真负率TNR：")#预测为假实际为假
    print(m[1][1]/(m[0][1]+m[1][1]))
    #print("十折交叉验证：")
    #score = cross_val_score(clf, X, Y, n_jobs=-1, cv=10)
    #print(np.mean(score))
    print(" ")

def randomforest(good_feature_vector_list,bad_feature_vector_list):
    X=GetTrainList.get_x_train(good_feature_vector_list,bad_feature_vector_list)
    Y=GetTrainList.get_y_train(good_feature_vector_list,bad_feature_vector_list)
    X_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size=0.3,random_state=0)#随机选择训练集和测试集
    

    clf =  RandomForestClassifier(n_estimators=180, max_depth=None,min_samples_split=2, random_state=None)
    clf.fit(X_train,Y_train) 
    Y_pred = clf.predict(X_test)

    print("随机森林测试结果：")

    print("分类正确率ACC：")
    print(metrics.accuracy_score(Y_test,Y_pred))
    #print("混淆矩阵：")
    m=metrics.confusion_matrix(Y_test,Y_pred)
    #print(m)
    print("真正率TPR：")#预测为真实际为真
    print(metrics.recall_score(Y_test,Y_pred))
    print("真负率TNR：")#预测为假实际为假
    print(m[1][1]/(m[0][1]+m[1][1]))
    #print("十折交叉验证：")
    #score = cross_val_score(clf, X, Y, n_jobs=-1, cv=10)
    #print(np.mean(score))
    print(" ")